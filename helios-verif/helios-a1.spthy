/*******************************************************************************************************************

This model is an adversary model for Helios voting protocol. 

In this model:

- Trustee and Voters are corrupted. 
  Server, Registrar and Voting Platform are honest.

- Voting phases are separated by restrictions.

- There are three options for public credentials of eligible voters:

	a) 'empty' option when there is no public information on BB.
	b) id option when identity of the voter is published on BB.
	c) alias option when alias is used for each eligible voter.

  Current code is executed for alias option. To make use of id option, it should be uncommented. 

- There is revoting in two options:
	
	1) with replacement of ballots on the BB. (Restriction: Ver_last)
	2) without replacement, i.e. keeping all cast ballots on the BB. (Restriction: Ver_last & Ver_mine)

- Verification is done in three ways:

	a) by checking BBcast in any time of the election.
	b) by checking BBtally in the end of election.
	c) by checking BBtally for empty ballots in the end of election.

- We only check verifiability properties.

- To obtain V_2, "restriction Ver_mine" should be uncommented:

  V_1 (1a) : IV0, EL10, CL0, RS1, RS20 with last restriction.    
  V_2 (2a) : IV0, EL10, CL0, RS1, RS20 with last and mine restrictions.    
  V_3 (b)  : IV1, EL11, CL1, RS1, RS21
  V_4 (c)  : IV2, EL12, CL2, RS1, RS22

- Execution time for alias option: 0m10.687s (without mine)
                                   0m7.608s  (with mine)

- Execution time for id option: 0m9.378s (without mine)
                                0m6.677s (with mine)

- Results for both alias and id options:

  Reachability_from_BBtally_to_BBreg (exists-trace): verified (12 steps)
  Weak_Individual_Verifiability_0 (all-traces): verified (96 steps)
  Individual_Verifiability_0 (all-traces): falsified - found trace (17 steps)
  Individual_Verifiability_1 (all-traces): verified (10 steps)
  Individual_Verifiability_2 (all-traces): verified (4 steps)
  Eligibility_1_0 (all-traces): verified (6 steps)
  Eligibility_1_1 (all-traces): verified (6 steps)
  Eligibility_1_2 (all-traces): verified (3 steps)
  Eligibility_2 (all-traces): verified (5 steps)
  No_Clash_at_Verification_0 (all-traces): verified (18 steps)
  No_Clash_at_Verification_1 (all-traces): verified (18 steps)
  No_Clash_at_Verification_2 (all-traces): verified (5 steps)
  Result_1 (all-traces): verified (53 steps)
  Result_2_0 (all-traces): verified (79 steps)
  Result_2_1 (all-traces): verified (21 steps)
  Result_2_2 (all-traces): verified (13 steps)
  Homomorphic_Tally_Property (all-traces): verified (9 steps)

*******************************************************************************************************************/


theory Helios_Verifiability_A1
begin
 
builtins: asymmetric-encryption, hashing

functions: enc/3, dec/2, proof1/3, ver1/4, ok/0

equations: dec(enc(x, pk(y), z), y) = x,
           ver1(proof1(enc(x1, y, z), z, <x1, x2>), enc(x1, y, z), y, <x1, x2>) = ok,
           ver1(proof1(enc(x2, y, z), z, <x1, x2>), enc(x2, y, z), y, <x1, x2>) = ok


// SETUP


rule Trustee_key: //generates election secret/public keys.
    [ Fr(~sK) ]
  --[ BB_key(pk(~sK)), OnlyOnce('key'), Phase('setup') ]->
    [ !Sk(~sK), !BBkey(pk(~sK)), Out(pk(~sK)) ]


rule Corrupted_Trustee_key: //allows adversary to choose election secret key.
    [ In(sK) ] 
  --[ BB_key(pk(sK)), OnlyOnce('key'), Phase('setup') ]-> 
    [ !Sk(sK), !BBkey(pk(sK)) ]


rule Administrator_cand: //sets up candidates.
    [ In(<x1, x2>) ] 
  --[ BB_cand(x1), BB_cand(x2), V_list(<x1, x2>), OnlyOnce('cand'), Phase('setup') ]-> 
    [ !BBcand(x1), !BBcand(x2), !Vlist(<x1, x2>) ]

   
rule Administrator_id: //sets up voters.
    [ In(id) ] --[ Phase('setup') ]-> [ !Id(id) ] 


rule Registrar_Server_reg: //assigns a public credential and a random password to each voter.
  let
      //cr = 'empty'
      //cr = id
      cr = ~alias //public credential is randomly chosen alias in Helios, i.e. an element from the set {V1,...,Vn} where n is the number of voters.
  in
    [ !Id(id), Fr(~alias), Fr(~pwd) ] 
  --[ BB_reg(cr), OnlyOnce(<id, 'reg'>), Phase('setup') ]-> 
    [ !Reg(id, cr), !Pwd(id, ~pwd), !BBreg(cr), Out(cr) ]


rule Server_bb: //prepares BB before election by allocating a place for each registered voter.
    [ !BBreg(cr) ] 
  --[ BB_cast(cr, 'empty'), OnlyOnce(<cr, 'bb'>), Phase('setup') ]-> 
    [ !BBcast(cr, 'empty') ]


// VOTING


rule Corrupted_Voter_corr: //leaks credentials to the adversary.
    [ !Reg(id, cr), !Pwd(id, pwd) ] 
  --[ Corr(id, cr), Phase('voting') ]-> 
    [ Out( <id, cr, pwd> ) ]


rule Voting_Platform_vote: //generates the ballot, authenticates and sends it to the server.
  let 
      c = enc(v, pkey, ~r)    //ciphertext
      pr1 = proof1(c, ~r, x)  //zero-knowledge proof
      b = <c, pr1>            //ballot
      a = h(<id, pwd, b>)     //authentication by hash function
  in
    [ !BBcand(v), !BBkey(pkey), Fr(~r), !Vlist(x), !Reg(id, cr), !Pwd(id, pwd) ]
  --[ Vote(id, cr, v), VoteB(id, cr, b), Phase('voting') ]->
    [ !Voted(id, cr, v, b), Out( <id, b, a> ) ]
 

rule Registrar_Server_cast: //authenticates the voter and verifies validity of the vote, if verified, publishes the ballot on BB.
  let
      b = <c, pr1>
      a1 = h(<id, pwd, b>)
  in
    [ In( <id, b, a> ), !BBkey(pkey), !Vlist(x), !Reg(id, cr), !Pwd(id, pwd) ]
  --[ Eq(a, a1), Eq(ver1(pr1, c, pkey, x), ok), VScast(id, b), BB_cast(cr, b), Phase('voting') ]->
    [ !BBcast(cr, b) ] 


restriction Server_Election_Auditors_cast: //ballot validity checks
"
  All cr b #i. BB_cast(cr, b) @i ==> Ex #j. BB_reg(cr) @j & ( b = 'empty'
  | ( Ex c pr1 pkey v r x1 x2 #k #l. BB_key(pkey) @k & V_list(<x1, x2>) @l 
      & b = <c, pr1> & c = enc(v, pkey, r) & (v = x1 | v = x2) ) )
"

rule Voter_ver_0: //verifies BBcast that it has her/his ballot.
    [ !Voted(id, cr, v, b), !BBcast(cr, b) ]
  --[ Verified_0(id, cr, v), VerB(id, cr, b) ]->
    [  ]


// TALLY


rule Server_tally: //selects the ballot to be tallied.
    [ !BBcast(cr, b) ]
  --[ BB_tally(cr, b), OnlyOnce(<cr, 'tally'>), Phase('tally') ]->
    [ !BBtally(cr, b) ]


restriction Server_Election_Auditors_tally: //selects the last ballot among all cast ballots.
"
  All cr b b1 #i #j #k. BB_cast(cr, b) @i & BB_cast(cr, b1) @j & BB_tally(cr, b) @k 
  ==> j < i | b = b1
"

rule Voter_ver_1: //verifies BBtally that it has her/his last ballot.
    [ !Voted(id, cr, v, b), !BBtally(cr, b) ]
  --[ Verified_1(id, cr, v), Phase('tally') ]->
    [  ]


rule Voter_ver_2: //verifies BBtally that there is no ballot on behalf of her/him.
    [ !Reg(id, cr), !BBtally(cr, 'empty') ]
  --[ Verified_2(id, cr, 'empty'), Phase('tally') ]->
    [  ]


// RESTRICTIONS


restriction OnlyOnce:
" 
  All x #i #j. OnlyOnce(x) @i & OnlyOnce(x) @j ==> #i = #j
"
restriction Equality:
"
  All x y #i. Eq(x,y) @i ==> x = y
"
restriction Phase_Order_1:
"
  All #i #j. Phase('setup') @i & Phase('voting') @j ==> i < j
"
restriction Phase_Order_2:
"
  All #i #j. Phase('voting') @i & Phase('tally') @j ==> i < j
"
restriction Cast_order: //server accepts ballots with respect to the cast order. (Only for honest server case)
"
  All id cr b b1 #i #j #k #l. VoteB(id, cr, b) @i & VoteB(id, cr, b1) @j 
  & VScast(id, b) @k & VScast(id, b1) @l & i < j ==> k < l
"
restriction Ver_last: //among all casts, the last one on BB is verified.
"
  All id cr b b1 #i #j #k. BB_cast(cr, b) @i & BB_cast(cr, b1) @j & VerB(id, cr, b) @k 
  & i < k & j < k ==> j < i | b = b1
"
/*
restriction Ver_mine: //all ballots on BB should have been cast by the same id.  
"
  All id cr b b1 #i #j. VerB(id, cr, b) @i & BB_cast(cr, b1) @j & j < i 
  ==> Ex #k. VoteB(id, cr, b1) @k
"
*/

// LEMMAS 


lemma Reachability_from_BBtally_to_BBreg:
exists-trace
" 
  Ex cr b #i #j #k #l #m. BB_reg(cr) @i & BB_cast(cr, 'empty') @j
  & Vote('Alice', cr, 'A') @k & BB_cast(cr, b) @l & BB_tally(cr, b) @m
"


// INDIVIDUAL VERIFIABILITY


lemma Weak_Individual_Verifiability_0:
"
  All id cr v b #i #j. Verified_0(id, cr, v) @i & BB_tally(cr, b) @j 
  & ( All v1 #k1 #k2. Vote(id, cr, v) @k1 & Vote(id, cr, v1) @k2 ==> k2 < k1 | v = v1 )  
  ==> ( Ex c pr1 pkey r #l. BB_key(pkey) @l & b = <c, pr1> & c = enc(v, pkey, r) )
      | ( Ex #m. Corr(id, cr) @m ) 
"

lemma Individual_Verifiability_0:
"
  All id cr v b #i #j. Verified_0(id, cr, v) @i & BB_tally(cr, b) @j 
  & ( All v1 #k1 #k2. Vote(id, cr, v) @k1 & Vote(id, cr, v1) @k2 ==> k2 < k1 | v = v1 )
  ==> ( Ex c pr1 pkey r #l. BB_key(pkey) @l & b = <c, pr1> & c = enc(v, pkey, r) ) 
"

lemma Individual_Verifiability_1:
"
  All id cr v b #i #j. Verified_1(id, cr, v) @i & BB_tally(cr, b) @j 
  ==> ( Ex c pr1 pkey r #k. BB_key(pkey) @k & b = <c, pr1> & c = enc(v, pkey, r) )
"

lemma Individual_Verifiability_2:
"
  All id cr b #i #j. Verified_2(id, cr, 'empty') @i & BB_tally(cr, b) @j 
  ==> b = 'empty'
"


// ELIGIBILITY


lemma Eligibility_1_0:
"
  All id cr v #i. Verified_0(id, cr, v) @i ==> Ex #j. BB_reg(cr) @j  
"

lemma Eligibility_1_1:
"
  All id cr v #i. Verified_1(id, cr, v) @i ==> Ex #j. BB_reg(cr) @j  
"

lemma Eligibility_1_2:
"
  All id cr #i. Verified_2(id, cr, 'empty') @i ==> Ex #j. BB_reg(cr) @j  
"

lemma Eligibility_2:
"
  All cr b #i. BB_tally(cr, b) @i ==> Ex #j. BB_reg(cr) @j  
"


// CLASH


lemma No_Clash_at_Verification_0:
"
  All id1 id2 cr v1 v2 #i #j. Verified_0(id1, cr, v1) @i & Verified_0(id2, cr, v2) @j 
  ==> id1 = id2 
"

lemma No_Clash_at_Verification_1:
"
  All id1 id2 cr v1 v2 #i #j. Verified_1(id1, cr, v1) @i & Verified_1(id2, cr, v2) @j 
  ==> id1 = id2 
"

lemma No_Clash_at_Verification_2:
"
  All id1 id2 cr #i #j. Verified_2(id1, cr, 'empty') @i & Verified_2(id2, cr, 'empty') @j 
  ==> id1 = id2 
"


// RESULT


lemma Result_1:
"
  All cr b #i. BB_tally(cr, b) @i & not(b = 'empty') 
  ==> ( Ex id c pr1 v pkey r #j #k. BB_key(pkey) @j & Vote(id, cr, v) @k 
        & b = <c, pr1> & c = enc(v, pkey, r) ) 
      | ( Ex id #j. Corr(id, cr) @j )  
"

lemma Result_2_0:
"
  All cr b #i. BB_tally(cr, b) @i & not(b = 'empty') 
  ==> ( Ex id c pr1 v pkey r #j #k. BB_key(pkey) @j & Vote(id, cr, v) @k 
        & b = <c, pr1> & c = enc(v, pkey, r) ) 
      | ( Ex id #j. Corr(id, cr) @j )  
      | not( Ex id v1 #j. Verified_0(id, cr, v1) @j )
"

lemma Result_2_1:
"
  All cr b #i. BB_tally(cr, b) @i & not(b = 'empty') 
  ==> ( Ex id c pr1 v pkey r #j #k. BB_key(pkey) @j & Vote(id, cr, v) @k 
        & b = <c, pr1> & c = enc(v, pkey, r) ) 
      | ( Ex id #j. Corr(id, cr) @j )  
      | not( Ex id v1 #j. Verified_1(id, cr, v1) @j )
"

lemma Result_2_2:
"
  All cr b #i. BB_tally(cr, b) @i & not(b = 'empty') 
  ==> ( Ex id c pr1 v pkey r #j #k. BB_key(pkey) @j & Vote(id, cr, v) @k 
        & b = <c, pr1> & c = enc(v, pkey, r) ) 
      | ( Ex id #j. Corr(id, cr) @j )  
      | not( Ex id #j. Verified_2(id, cr, 'empty') @j )
"


// HOMOMORPHIC TALLY PROPERTY 


lemma Homomorphic_Tally_Property:
"
  All cr b #i. BB_tally(cr, b) @i & not(b = 'empty')
  ==> Ex c pr1 v pkey r #j. BB_cand(v) @j & b = <c, pr1> & c = enc(v, pkey, r)   
"

end